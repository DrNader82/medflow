<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MedFlow | Inicio - Donde el Razonamiento Clínico Fluye</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

    <style>
        /* Aplicar la fuente Inter al cuerpo del documento por defecto */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Estilos para la sección del juego */
        #descanso-mental {
            background-color: #222; /* Fondo oscuro para la sección del juego */
            color: #eee; /* Texto claro para la sección del juego */
            padding: 20px;
            border-radius: 8px; /* Bordes redondeados */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); /* Sombra */
            display: flex; /* Usar flexbox para centrar contenido */
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #descanso-mental h2 {
            font-family: 'Inter', sans-serif; /* Título de la sección con fuente principal */
            color: #eee; /* Color del título de la sección */
            margin-bottom: 20px;
        }

        /* ESTILOS ESPECÍFICOS DEL JUEGO ANDY SONIC DIGGER */
        /* Aplicar la fuente del juego solo a los elementos del juego */
        #game-wrapper {
             display: flex; /* Contenedor del juego usa flexbox */
             flex-direction: column;
             align-items: center;
             justify-content: center;
             width: 100%; /* Ocupa el ancho del contenedor padre */
        }

        .game-container {
            text-align: center;
            width: 100%;
            max-width: 400px; /* Match canvas max-width */
            margin-top: 0; /* Ajustar margen superior */
            font-family: 'Press Start 2P', cursive; /* Fuente del juego */
        }

        .game-title {
            font-size: 1.8em;
            margin-bottom: 20px;
            color: gold;
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
        }

        .info-bar {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 10px;
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
        }

        .score, .level {
            font-size: 1.2em;
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
        }

        canvas {
            background-color: #554; /* Dirt color */
            display: block;
            border: 2px solid #eee;
            margin-bottom: 20px;
            max-width: 100%; /* Ensure canvas is responsive */
            height: auto; /* Maintain aspect ratio */
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #eee;
            display: none; /* Hidden by default */
            z-index: 100;
            text-align: center;
            width: 80%; /* Responsive width */
            max-width: 300px;
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
        }

        .message-box button {
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
            padding: 10px 20px;
            margin-top: 20px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            box-shadow: 3px 3px 0px #2e7d32;
            transition: background-color 0.3s ease;
        }

        .message-box button:hover {
            background-color: #388E3C;
        }

        /* Touch Controls Styling */
        .controls {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            width: 150px; /* Adjust size as needed */
            margin-top: 20px;
        }

        .control-button {
            font-family: 'Press Start 2P', cursive; /* Asegurar fuente del juego */
            padding: 15px;
            background-color: #333;
            color: #eee;
            border: 2px solid #eee;
            border-radius: 5px;
            cursor: pointer;
            text-align: center;
            user-select: none; /* Prevent text selection on touch */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            touch-action: manipulation; /* Prevent double tap zoom */
        }

        .control-button:active {
            background-color: #555;
        }


        /* Estilo para el botón de iniciar juego */
        #start-game-button {
            font-family: 'Inter', sans-serif; /* Fuente principal para el botón */
            padding: 15px 30px;
            font-size: 1.5em;
            background-color: #007bff; /* Color azul llamativo */
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease;
            margin-top: 20px;
        }

        #start-game-button:hover {
            background-color: #0056b3;
        }


        /* Responsive adjustments */
        @media (max-width: 600px) {
            canvas {
                width: 95vw;
                height: 95vw; /* Keep aspect ratio */
            }
            .info-bar {
                width: 95vw;
            }
            .score, .level {
                font-size: 1em;
            }
            .message-box {
                width: 90%; /* More width on smaller screens */
                padding: 15px;
            }
             .message-box button {
                padding: 8px 15px;
             }
             .controls {
                 width: 120px; /* Smaller controls on mobile */
                 gap: 5px;
             }
             .control-button {
                 padding: 10px;
             }
        }
        /* FIN DE ESTILOS CSS DEL JUEGO */
    </style>
</head>
<body class="bg-gray-900 text-white">

    <header class="bg-blue-900 text-white py-8 shadow-md">
        <div class="container mx-auto px-6 text-center">
            <h1 class="text-4xl md:text-5xl font-bold mb-2">MedFlow</h1>
            <p class="text-lg md:text-xl italic text-gray-200">Donde el razonamiento clínico fluye.</p>
        </div>
    </header>

    <main class="container mx-auto px-6 py-12">
        <h2 class="text-3xl font-semibold text-center mb-10 text-gray-100">Explora Nuestras Secciones</h2>

        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8">

            <a href="ibc/index.html" class="block transform transition duration-300 ease-in-out hover:scale-105 hover:shadow-xl">
                <div class="bg-white text-gray-800 rounded-lg shadow-lg p-6 h-full flex flex-col">
                    <h3 class="text-xl font-bold mb-3 text-blue-800">Integración Básico Clínica</h3>
                    <p class="text-gray-600 flex-grow">Infografías, resúmenes y casos clínicos relacionados para desarrollar el razonamiento clínico.</p>
                </div>
            </a>

            <a href="cardiologia/index.html" class="block transform transition duration-300 ease-in-out hover:scale-105 hover:shadow-xl">
                <div class="bg-yellow-100 text-gray-800 rounded-lg shadow-lg p-6 h-full flex flex-col">
                    <h3 class="text-xl font-bold mb-3 text-yellow-800">Cardiología</h3>
                    <p class="text-gray-700 flex-grow">Infografías y resúmenes interactivos de enfermedades frecuentes de cardiología, con un enfoque práctico y clínico.</p>
                </div>
            </a>

            <a href="casos-clinicos/index.html" class="block transform transition duration-300 ease-in-out hover:scale-105 hover:shadow-xl">
                <div class="bg-green-100 text-gray-800 rounded-lg shadow-lg p-6 h-full flex flex-col">
                    <h3 class="text-xl font-bold mb-3 text-green-800">Casos Clínicos</h3>
                    <p class="text-gray-700 flex-grow">Escenarios reales para discusión en clase, con preguntas de integración diagnóstica y terapéutica.</p>
                </div>
            </a>

            <a href="flow-cases/index.html" class="block transform transition duration-300 ease-in-out hover:scale-105 hover:shadow-xl">
                <div class="bg-blue-100 text-gray-800 rounded-lg shadow-lg p-6 h-full flex flex-col">
                    <h3 class="text-xl font-bold mb-3 text-blue-900">Flow Cases</h3>
                    <p class="text-gray-700 flex-grow">Casos interactivos paso a paso diseñados para practicar la toma de decisiones diagnósticas y terapéuticas.</p>
                </div>
            </a>

            <section id="descanso-mental" class="col-span-full bg-gray-800 rounded-lg shadow-lg p-6 mt-8">
                 <h2 class="text-3xl font-semibold text-center mb-6 text-gray-100">Descanso mental</h2>

                 <button id="start-game-button">Jugar Andy Sonic Digger</button>

                 <div id="game-wrapper" style="display: none;">
                     <div class="game-container">
                         <h1 class="game-title">Andy Sonic Digger</h1>
                         <div class="info-bar">
                             <div class="score">Score: <span id="scoreValue">0</span></div>
                             <div class="level">Level: <span id="levelValue">1</span></div>
                         </div>
                         <canvas id="gameCanvas"></canvas>

                         <div class="controls">
                             <button id="up-button" class="control-button">Up</button>
                             <button id="left-button" class="control-button">Left</button>
                             <button id="right-button" class="control-button">Right</button>
                             <button id="down-button" class="control-button">Down</button>
                         </div>
                     </div>

                     <div id="messageBox" class="message-box">
                         <p id="messageText"></p>
                         <button id="restartButton">Restart</button>
                     </div>
                     </div>


                 <script>
                     // CÓDIGO JAVASCRIPT DEL JUEGO ANDY SONIC DIGGER
                     // Get the canvas and context
                     const canvas = document.getElementById('gameCanvas');
                     const ctx = canvas.getContext('2d');
                     const scoreValue = document.getElementById('scoreValue');
                     const levelValue = document.getElementById('levelValue');
                     const messageBox = document.getElementById('messageBox');
                     const messageText = document.getElementById('messageText');
                     const restartButton = document.getElementById('restartButton');

                     // Get control buttons
                     const upButton = document.getElementById('up-button');
                     const downButton = document.getElementById('down-button');
                     const leftButton = document.getElementById('left-button');
                     const rightButton = document.getElementById('right-button');

                      // Get the start game button and game wrapper
                     const startGameButton = document.getElementById('start-game-button');
                     const gameWrapper = document.getElementById('game-wrapper');


                     // Variables for continuous movement
                     let moveInterval = null; // To store the interval ID for continuous movement
                     const moveRepeatFrequency = 100; // How often to trigger movePlayer in milliseconds (adjust as needed)


                     // Game settings
                     const gridSize = 20; // Size of each cell in pixels
                     const canvasSize = 400; // Total canvas size
                     const gridWidth = canvasSize / gridSize;
                     const gridHeight = canvasSize / gridSize;

                     // Adjust canvas size for responsiveness
                     // NOTA: El canvas ya tiene max-width: 100% y height: auto en CSS para ser responsive.
                     // Estas líneas pueden ser redundantes o causar problemas si no se maneja bien el redimensionamiento del canvas en el draw.
                     // canvas.width = canvasSize;
                     // canvas.height = canvasSize;

                     // Game state
                     let gameGrid = [];
                     let player = { x: 1, y: 1 }; // Player starting position
                     let score = 0;
                     let treasures = [];
                     let monsters = [];
                     let powerups = []; // Array for speed boost power-ups
                     let invincibilityPowerups = []; // Array for invincibility power-ups
                     let gameOver = false;
                     let currentLevel = 0; // Start at index 0 for Level 1

                     // Level Configurations (monsterFreq: higher = slower, treasureCount: number to collect, rockCount: number of rocks, powerupCount: number of speed boost powerups, invincibilityPowerupCount: number of invincibility powerups)
                     const levels = [
                         { monsterFreq: 45, treasureCount: 5, rockCount: 10, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 1
                         { monsterFreq: 42, treasureCount: 6, rockCount: 12, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 2
                         { monsterFreq: 39, treasureCount: 7, rockCount: 14, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 3
                         { monsterFreq: 36, treasureCount: 8, rockCount: 16, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 4
                         { monsterFreq: 33, treasureCount: 9, rockCount: 18, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 5
                         { monsterFreq: 30, treasureCount: 10, rockCount: 20, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 6
                         { monsterFreq: 27, treasureCount: 11, rockCount: 22, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 7
                         { monsterFreq: 24, treasureCount: 12, rockCount: 24, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 8
                         { monsterFreq: 21, treasureCount: 13, rockCount: 26, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 9
                         { monsterFreq: 18, treasureCount: 14, rockCount: 28, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 10
                         { monsterFreq: 15, treasureCount: 15, rockCount: 30, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 11
                         { monsterFreq: 12, treasureCount: 16, rockCount: 32, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 12
                         { monsterFreq: 10, treasureCount: 17, rockCount: 34, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 13
                         { monsterFreq: 8, treasureCount: 18, rockCount: 36, powerupCount: 6, invincibilityPowerupCount: 1 }, // Level 14
                         { monsterFreq: 6, treasureCount: 20, rockCount: 40, powerupCount: 6, invincibilityPowerupCount: 1 }  // Level 15
                     ];
                     const totalLevels = levels.length;

                     // Monster movement control
                     let monsterMoveCounter = 0;
                     const minMonsterDistance = 10; // Minimum distance from player start for monsters

                     // Speed boost control
                     let isSpeedBoostActive = false;
                     let speedBoostEndTime = 0;
                     const speedBoostDuration = 4000; // 4 seconds in milliseconds

                     // Invincibility control
                     let isInvincible = false;
                     let invincibilityEndTime = 0;
                     const invincibilityDuration = 5000; // 5 seconds in milliseconds


                     // Game objects
                     const DIRT = 0;
                     const EMPTY = 1;
                     const TREASURE = 2;
                     const PLAYER = 3;
                     const MONSTER = 4;
                     const ROCK = 5; // New object type for rocks
                     const SPEED_POWERUP = 6; // Object type for speed boost power-ups
                     const INVINCIBILITY_POWERUP = 7; // Object type for invincibility power-ups


                     // Colors
                     const colors = {
                         [DIRT]: '#554',
                         [EMPTY]: '#000', // Dug path
                         [TREASURE]: 'gold',
                         [PLAYER]: '#1E90FF', // Dodger Blue for player body (default)
                         [MONSTER]: 'red',
                         [ROCK]: '#888', // Color for rocks
                         [SPEED_POWERUP]: 'lime', // Bright green for speed boost power-ups
                         [INVINCIBILITY_POWERUP]: '#EE82EE' // Violet (lighter purple) for invincibility power-ups
                     };

                     // Initialize the game grid
                     function initGrid() {
                         gameGrid = [];
                         for (let y = 0; y < gridHeight; y++) {
                             const row = [];
                             for (let x = 0; x < gridWidth; x++) {
                                 row.push(DIRT); // Fill with dirt initially
                             }
                             gameGrid.push(row);
                         }
                     }

                     // Place rocks, player, treasures, monsters, and powerups for the current level
                     function setupLevel() {
                         initGrid(); // Start with a fresh grid

                         const levelConfig = levels[currentLevel];
                         const numTreasures = levelConfig.treasureCount;
                         const numRocks = levelConfig.rockCount;
                         const numMonsters = 3 + Math.floor(currentLevel / 3); // Increase monsters every few levels
                         const numSpeedPowerups = levelConfig.powerupCount; // Number of speed boost power-ups
                         const numInvincibilityPowerups = levelConfig.invincibilityPowerupCount; // Number of invincibility power-ups


                         // Place rocks
                         let rocksPlaced = 0;
                         while (rocksPlaced < numRocks) {
                              const x = Math.floor(Math.random() * gridWidth);
                              const y = Math.floor(Math.random() * gridHeight);
                              // Ensure rock is not near player start or on existing rock
                              if (gameGrid[y][x] === DIRT && (Math.abs(x - player.x) > 2 || Math.abs(y - player.y) > 2)) {
                                  gameGrid[y][x] = ROCK;
                                  rocksPlaced++;
                              }
                         }


                         // Place player
                         player = { x: 1, y: 1 }; // Player always starts here
                         gameGrid[player.y][player.x] = PLAYER;

                         // Place treasures
                         treasures = [];
                         while (treasures.length < numTreasures) {
                             const x = Math.floor(Math.random() * gridWidth);
                             const y = Math.floor(Math.random() * gridHeight);
                             // Ensure treasure is not on player, rock, or existing treasure
                             if (gameGrid[y][x] === DIRT) {
                                 gameGrid[y][x] = TREASURE;
                                 treasures.push({ x, y });
                             }
                         }

                          // Place speed boost power-ups
                         powerups = [];
                          while (powerups.length < numSpeedPowerups) {
                              const x = Math.floor(Math.random() * gridWidth);
                              const y = Math.floor(Math.random() * gridHeight);
                              // Ensure power-up is not on player, rock, treasure, or existing power-up
                              if (gameGrid[y][x] === DIRT) {
                                  gameGrid[y][x] = SPEED_POWERUP;
                                  powerups.push({ x, y });
                              }
                          }

                          // Place invincibility power-ups
                         invincibilityPowerups = [];
                          while (invincibilityPowerups.length < numInvincibilityPowerups) {
                              const x = Math.floor(Math.random() * gridWidth);
                              const y = Math.floor(Math.random() * gridHeight);
                              // Ensure power-up is not on player, rock, treasure, speed power-up, or existing invincibility power-up
                              if (gameGrid[y][x] === DIRT) {
                                  gameGrid[y][x] = INVINCIBILITY_POWERUP;
                                  invincibilityPowerups.push({ x, y });
                              }
                          }


                         // Place monsters
                         monsters = [];
                          while (monsters.length < numMonsters) {
                             const x = Math.floor(Math.random() * gridWidth);
                             const y = Math.floor(Math.random() * gridHeight);
                              // Calculate distance from player start
                              const distance = Math.sqrt(Math.pow(x - player.x, 2) + Math.pow(y - player.y, 2));

                              // Ensure monster is not on player, treasure, rock, any power-up, existing monster, AND is far enough from player start
                             if (gameGrid[y][x] === DIRT && distance >= minMonsterDistance) {
                                 gameGrid[y][x] = MONSTER;
                                 monsters.push({ x, y });
                             }
                           }

                         monsterMoveCounter = 0; // Reset counter for the new level
                         levelValue.textContent = currentLevel + 1; // Update level display
                         isSpeedBoostActive = false; // Ensure boost is off at start of level
                         speedBoostEndTime = 0;
                         isInvincible = false; // Ensure invincibility is off at start of level
                         invincibilityEndTime = 0;
                     }

                     // Draw the game grid
                     function drawGrid() {
                         ctx.clearRect(0, 0, canvasSize, canvasSize); // Clear canvas
                         for (let y = 0; y < gridHeight; y++) {
                             for (let x = 0; x < gridWidth; x++) {
                                 const cellType = gameGrid[y][x];
                                 ctx.fillStyle = colors[cellType];
                                 ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);

                                 // Draw grid lines (optional)
                                 ctx.strokeStyle = '#333';
                                 ctx.strokeRect(x * gridSize, y * gridSize, gridSize, gridSize);
                             }
                         }
                     }

                     // Draw player, treasures, monsters, rocks, and powerups on top of the grid
                     function drawGameObjects() {
                          // Draw treasures (Rings)
                         ctx.strokeStyle = colors[TREASURE]; // Use gold for the ring outline
                         ctx.lineWidth = 3; // Thickness of the ring
                         ctx.fillStyle = '#000'; // Black for the inner circle

                         treasures.forEach(t => {
                             const treasureX = t.x * gridSize + gridSize / 2; // Center X
                             const treasureY = t.y * gridSize + gridSize / 2; // Center Y
                             const outerRadius = gridSize * 0.4; // Radius of the outer ring
                             const innerRadius = gridSize * 0.2; // Radius of the inner black circle

                             // Draw the outer gold ring
                             ctx.beginPath();
                             ctx.arc(treasureX, treasureY, outerRadius, 0, Math.PI * 2);
                             ctx.stroke(); // Draw the outline

                             // Draw the inner black circle
                             ctx.beginPath();
                             ctx.arc(treasureX, treasureY, innerRadius, 0, Math.PI * 2);
                             ctx.fill(); // Fill the inner circle with black
                         });

                         // Draw rocks (simple gray squares)
                         ctx.fillStyle = colors[ROCK];
                          for (let y = 0; y < gridHeight; y++) {
                              for (let x = 0; x < gridWidth; x++) {
                                  if (gameGrid[y][x] === ROCK) {
                                      ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                                  }
                              }
                          }


                          // Draw speed boost power-ups (Emeralds - simple diamond shape)
                          ctx.fillStyle = colors[SPEED_POWERUP];
                          powerups.forEach(p => {
                              const powerupX = p.x * gridSize;
                              const powerupY = p.y * gridSize;

                              ctx.beginPath();
                              ctx.moveTo(powerupX + gridSize / 2, powerupY); // Top center
                              ctx.lineTo(powerupX + gridSize, powerupY + gridSize / 2); // Right center
                              ctx.lineTo(powerupX + gridSize / 2, powerupY + gridSize); // Bottom center
                              ctx.lineTo(powerupX, powerupY + gridSize / 2); // Left center
                              ctx.closePath();
                              ctx.fill();
                          });

                          // Draw invincibility power-ups (Purple Gems - simple diamond shape)
                          ctx.fillStyle = colors[INVINCIBILITY_POWERUP];
                          invincibilityPowerups.forEach(p => {
                              const powerupX = p.x * gridSize;
                              const powerupY = p.y * gridSize;

                              ctx.beginPath();
                              ctx.moveTo(powerupX + gridSize / 2, powerupY); // Top center
                              ctx.lineTo(powerupX + gridSize, powerupY + gridSize / 2); // Right center
                              ctx.lineTo(powerupX + gridSize / 2, powerupY + gridSize); // Bottom center
                              ctx.lineTo(powerupX, powerupY + gridSize / 2); // Left center
                              ctx.closePath();
                              ctx.fill();
                          });


                         // Draw monsters
                         monsters.forEach(m => {
                             const monsterX = m.x * gridSize;
                             const monsterY = m.y * gridSize;

                             // Draw monster body (red)
                             ctx.fillStyle = colors[MONSTER];
                             ctx.fillRect(monsterX, monsterY, gridSize, gridSize);

                             // Draw angry face (black)
                             ctx.fillStyle = '#000'; // Black for face features

                             // Eyes
                             const eyeSize = gridSize * 0.15;
                             const eyeOffsetY = gridSize * 0.25;
                             const eyeOffsetX = gridSize * 0.25;
                             ctx.fillRect(monsterX + eyeOffsetX, monsterY + eyeOffsetY, eyeSize, eyeSize); // Left eye
                             ctx.fillRect(monsterX + gridSize - eyeOffsetX - eyeSize, monsterY + eyeOffsetY, eyeSize, eyeSize); // Right eye

                             // Angry eyebrows (slanted rectangles)
                             const eyebrowWidth = gridSize * 0.3;
                             const eyebrowHeight = gridSize * 0.08;
                             const eyebrowOffsetY = gridSize * 0.15;
                             const eyebrowOffsetX = gridSize * 0.15;

                             // Left eyebrow (slanted down to the right)
                             ctx.save(); // Save current canvas state
                             ctx.translate(monsterX + eyebrowOffsetX, monsterY + eyebrowOffsetY);
                             ctx.rotate(Math.PI / 10); // Rotate slightly
                             ctx.fillRect(0, 0, eyebrowWidth, eyebrowHeight);
                             ctx.restore(); // Restore canvas state

                             // Right eyebrow (slanted down to the left)
                             ctx.save(); // Save current canvas state
                             ctx.translate(monsterX + gridSize - eyebrowOffsetX, monsterY + eyebrowOffsetY);
                             ctx.rotate(-Math.PI / 10); // Rotate slightly in the opposite direction
                             ctx.fillRect(-eyebrowWidth, 0, eyebrowWidth, eyebrowHeight); // Draw from the right edge
                             ctx.restore(); // Restore canvas state


                             // Mouth (simple line or rectangle)
                             const mouthWidth = gridSize * 0.4;
                             const mouthHeight = gridSize * 0.1;
                             const mouthOffsetY = gridSize * 0.65;
                             const mouthOffsetX = (gridSize - mouthWidth) / 2;
                             ctx.fillRect(monsterX + mouthOffsetX, monsterY + mouthOffsetY, mouthWidth, mouthHeight); // Simple rectangular mouth


                         });

                         // Draw player (draw last so it's on top)
                         const playerX = player.x * gridSize;
                         const playerY = player.y * gridSize;

                         // Determine player color based on invincibility
                         const playerColor = isInvincible ? 'yellow' : colors[PLAYER];

                         // Draw Digger body
                         ctx.fillStyle = playerColor;
                         ctx.fillRect(playerX + gridSize * 0.1, playerY + gridSize * 0.4, gridSize * 0.8, gridSize * 0.5); // Main body

                         // Draw cabin (darker blue/yellow based on invincibility)
                         ctx.fillStyle = isInvincible ? '#CCCC00' : '#00008B'; // Darker yellow or dark blue
                         ctx.fillRect(playerX + gridSize * 0.3, playerY + gridSize * 0.2, gridSize * 0.4, gridSize * 0.3); // Cabin

                         // Draw arm (gray)
                         ctx.fillStyle = '#A9A9A9'; // Dark gray
                         ctx.fillRect(playerX + gridSize * 0.6, playerY + gridSize * 0.3, gridSize * 0.3, gridSize * 0.1); // Arm segment 1
                          ctx.fillRect(playerX + gridSize * 0.75, playerY + gridSize * 0.4, gridSize * 0.15, gridSize * 0.3); // Arm segment 2 (bucket arm)


                         // Draw bucket (darker gray)
                         ctx.fillStyle = '#696969'; // Dim gray
                          ctx.beginPath();
                          ctx.moveTo(playerX + gridSize * 0.8, playerY + gridSize * 0.7);
                          ctx.lineTo(playerX + gridSize * 0.95, playerY + gridSize * 0.65);
                          ctx.lineTo(playerX + gridSize * 0.9, playerY + gridSize * 0.75);
                          ctx.lineTo(playerX + gridSize * 0.8, playerY + gridSize * 0.75);
                          ctx.closePath();
                          ctx.fill();

                          // Draw tracks (black)
                          ctx.fillStyle = '#000';
                          ctx.fillRect(playerX + gridSize * 0.1, playerY + gridSize * 0.85, gridSize * 0.3, gridSize * 0.1); // Left track
                          ctx.fillRect(playerX + gridSize * 0.6, playerY + gridSize * 0.85, gridSize * 0.3, gridSize * 0.1); // Right track

                         // Draw spikes (blue/yellow based on invincibility)
                         ctx.fillStyle = playerColor; // Use player color (blue or yellow)
                         const spikeBaseWidth = gridSize * 0.2;
                         const spikeHeight = gridSize * 0.2;
                         const spikeOffsetY = playerY + gridSize * 0.1; // Position above the cabin

                         // Spike 1
                         ctx.beginPath();
                         ctx.moveTo(playerX + gridSize * 0.2, spikeOffsetY + spikeHeight);
                         ctx.lineTo(playerX + gridSize * 0.3, spikeOffsetY);
                         ctx.lineTo(playerX + gridSize * 0.4, spikeOffsetY + spikeHeight);
                         ctx.closePath();
                         ctx.fill();

                         // Spike 2
                         ctx.beginPath();
                         ctx.moveTo(playerX + gridSize * 0.4, spikeOffsetY + spikeHeight);
                         ctx.lineTo(playerX + gridSize * 0.5, spikeOffsetY);
                         ctx.lineTo(playerX + gridSize * 0.6, spikeOffsetY + spikeHeight);
                         ctx.closePath();
                         ctx.fill();

                         // Spike 3
                         ctx.beginPath();
                         ctx.moveTo(playerX + gridSize * 0.6, spikeOffsetY + spikeHeight);
                         ctx.lineTo(playerX + gridSize * 0.7, spikeOffsetY);
                         ctx.lineTo(playerX + gridSize * 0.8, spikeOffsetY + spikeHeight);
                         ctx.closePath();
                         ctx.fill();
                     }

                     // Function to stop continuous movement
                     function stopMove() {
                         clearInterval(moveInterval);
                         moveInterval = null;
                     }

                     // Handle player movement (called by both keyboard and touch/mouse controls)
                     function movePlayer(dx, dy) {
                         if (gameOver) return;

                         // Determine how many steps to attempt based on speed boost
                         const steps = isSpeedBoostActive ? 2 : 1; // Move 2 cells if boosted, 1 otherwise

                         let currentX = player.x;
                         let currentY = player.y;

                         for (let i = 0; i < steps; i++) {
                             const nextX = currentX + dx;
                             const nextY = currentY + dy;

                             // Check boundaries for the *next* potential position
                             if (nextX < 0 || nextX >= gridWidth || nextY < 0 || nextY >= gridHeight) {
                                 break; // Stop if next step is out of bounds
                             }

                             const targetCellContent = gameGrid[nextY][nextX];

                             // Prevent moving through rocks
                             if (targetCellContent === ROCK) {
                                 break; // Stop movement for this key press if a rock is hit
                             }

                              // Check for collision with monster *before* moving into the cell
                              if (targetCellContent === MONSTER) {
                                  if (!isInvincible) { // Only lose if not invincible
                                      // Collision with monster
                                      player.x = nextX; // Move player to the monster's cell for visual feedback
                                      player.y = nextY;
                                      endGame("Game Over! You are too SLOOOW!!!"); // Corrected Game Over message
                                      draw(); // Redraw one last time to show collision
                                      return; // Stop processing further steps and the current move
                                  } else {
                                      // If invincible, just move through the monster (monster stays)
                                       // Mark the monster's old position as empty (dug) if needed
                                      if (gameGrid[monster.y][monster.x] !== TREASURE && gameGrid[monster.y][monster.x] !== SPEED_POWERUP && gameGrid[monster.y][monster.x] !== INVINCIBILITY_POWERUP) {
                                          gameGrid[monster.y][monster.x] = EMPTY;
                                      }
                                       // Remove the monster
                                       monsters = monsters.filter(m => m.x !== nextX || m.y !== nextY);
                                       // The grid cell will be marked as PLAYER below
                                  }
                              }


                             // Mark the current player position as empty (dug), unless it was a special object
                              if (gameGrid[currentY][currentX] !== TREASURE && gameGrid[currentY][currentX] !== MONSTER && gameGrid[currentY][currentX] !== SPEED_POWERUP && gameGrid[currentY][currentX] !== INVINCIBILITY_POWERUP) {
                                   gameGrid[currentY][currentX] = EMPTY;
                              }


                             // Update current position for the next iteration of the loop
                             currentX = nextX;
                             currentY = nextY;

                             // Check what's in the new cell AFTER moving one step
                              if (gameGrid[currentY][currentX] === TREASURE) {
                                  score += 100; // Increase score for treasure
                                  scoreValue.textContent = score;
                                  // Remove the collected treasure
                                  treasures = treasures.filter(t => t.x !== currentX || t.y !== currentY);
                                   gameGrid[currentY][currentX] = PLAYER; // Player is now in this cell

                                   // Check if all treasures are collected for the current level
                                  if (treasures.length === 0) {
                                     if (currentLevel < totalLevels - 1) {
                                         // Move to next level
                                         currentLevel++;
                                         setupLevel(); // Setup the next level
                                         return; // Stop processing steps and the current move
                                     } else {
                                         // Game completed!
                                         endGame("Genial! Terminaste el juego! Ahora a seguir estudiando!");
                                         return; // Stop processing steps and the current move
                                     }
                                  }

                              } else if (gameGrid[currentY][currentX] === SPEED_POWERUP) {
                                   score += 50; // Points for collecting speed power-up
                                   scoreValue.textContent = score;
                                   // Remove the collected power-up
                                   powerups = powerups.filter(p => p.x !== currentX || p.y !== currentY);
                                   // Activate speed boost
                                   isSpeedBoostActive = true;
                                   speedBoostEndTime = Date.now() + speedBoostDuration;
                                   gameGrid[currentY][currentX] = PLAYER; // Player is now in this cell

                              } else if (gameGrid[currentY][currentX] === INVINCIBILITY_POWERUP) {
                                   score += 150; // Points for collecting invincibility power-up (example points)
                                   scoreValue.textContent = score;
                                   // Remove the collected power-up
                                   invincibilityPowerups = invincibilityPowerups.filter(p => p.x !== currentX || p.y !== currentY);
                                   // Activate invincibility
                                   isInvincible = true;
                                   invincibilityEndTime = Date.now() + invincibilityDuration;
                                    // The player color will be handled in the draw function
                                   gameGrid[currentY][currentX] = PLAYER; // Player is now in this cell

                              } else {
                                   // If the cell is empty or dirt after moving, mark it as player
                                   gameGrid[currentY][currentX] = PLAYER;
                              }
                         }

                          // Update the actual player position after the loop finishes
                          player.x = currentX;
                          player.y = currentY;


                          // Redraw after completing all steps for this key press
                          draw();
                     }

                     // Simple monster movement (move towards player)
                     function moveMonsters() {
                          if (gameOver) return;

                         monsters.forEach(monster => {
                             // Temporarily remove monster from grid to check next move
                              if (gameGrid[monster.y][monster.x] !== TREASURE && gameGrid[monster.y][monster.x] !== PLAYER && gameGrid[monster.y][monster.x] !== SPEED_POWERUP && gameGrid[monster.y][monster.x] !== INVINCIBILITY_POWERUP) {
                                  gameGrid[monster.y][monster.x] = EMPTY; // Or DIRT, depending on desired behavior
                              }

                             let dx = 0;
                             let dy = 0;

                             // Determine direction towards player
                             if (player.x > monster.x) dx = 1;
                             else if (player.x < monster.x) dx = -1;

                             if (player.y > monster.y) dy = 1;
                             else if (player.y < monster.y) dy = -1;

                             // Try moving horizontally first, then vertically if horizontal is blocked
                             let newX = monster.x + dx;
                             let newY = monster.y;
                             let moved = false;

                             // Check horizontal move - avoid rocks and other monsters
                             if (dx !== 0 && newX >= 0 && newX < gridWidth && gameGrid[newY][newX] !== MONSTER && gameGrid[newY][newX] !== ROCK) {
                                  monster.x = newX;
                                  moved = true;
                             } else {
                                 // If horizontal move blocked or not attempted, try vertical - avoid rocks and other monsters
                                 newX = monster.x;
                                 newY = monster.y + dy;
                                  if (dy !== 0 && newY >= 0 && newY < gridHeight && gameGrid[newY][newX] !== MONSTER && gameGrid[newY][newX] !== ROCK) {
                                      monster.y = newY;
                                      moved = true;
                                  }
                             }

                             // If couldn't move towards player, try random move as fallback (optional) - avoid rocks and other monsters
                             if (!moved) {
                                  const directions = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy -1 }];
                                  const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                                  newX = monster.x + randomDirection.dx;
                                  newY = monster.y + randomDirection.dy;

                                  if (newX >= 0 && newX < gridWidth && newY >= 0 && newY < gridHeight && gameGrid[newY][newX] !== MONSTER && gameGrid[newY][newX] !== ROCK) {
                                       monster.x = newX;
                                       monster.y = newY;
                                  }
                             }


                              // Check for collision with player AFTER monster moves
                             if (monster.x === player.x && monster.y === player.y) {
                                 if (!isInvincible) { // Only lose if not invincible
                                      endGame("Game Over! You are too SLOOOW!!!"); // Corrected Game Over message
                                 } else {
                                      // If invincible, remove the monster
                                      monsters = monsters.filter(m => m !== monster); // Remove this specific monster instance
                                      // The grid cell will remain PLAYER (or whatever the player is on)
                                  }
                             } else {
                                  // Place monster in new cell, unless it's a treasure, rock, or powerup
                                  if (gameGrid[monster.y][monster.x] !== TREASURE && gameGrid[monster.y][monster.x] !== ROCK && gameGrid[monster.y][monster.x] !== SPEED_POWERUP && gameGrid[monster.y][monster.x] !== INVINCIBILITY_POWERUP) {
                                      gameGrid[monster.y][monster.x] = MONSTER;
                                  } else {
                                      // If moving onto a treasure, rock, or powerup, that object remains, monster is drawn on top
                                      // The grid still shows TREASURE/ROCK/POWERUP, but monster is at this location
                                  }
                             }
                         });
                     }


                     // End the game
                     function endGame(message) {
                         gameOver = true;
                         messageText.textContent = message;
                         messageBox.style.display = 'block';
                          // If game is won, change restart button text and action slightly (optional)
                          if (currentLevel === totalLevels - 1 && treasures.length === 0) {
                              restartButton.textContent = "Play Again";
                              restartButton.onclick = restartGame; // Ensure it restarts from level 1
                          } else {
                              restartButton.textContent = "Restart Level";
                              restartButton.onclick = restartLevel; // Restart the current level
                          }
                          stopMove(); // Stop any continuous movement on game over
                     }

                     // Restart the current level
                     function restartLevel() {
                          gameOver = false;
                          messageBox.style.display = 'none';
                          // Don't reset score or level, just re-setup the current level
                          setupLevel();
                          gameLoop(); // Ensure game loop is running
                     }


                     // Restart the entire game from level 1
                     function restartGame() {
                         gameOver = false;
                         score = 0;
                         currentLevel = 0; // Start from level 1
                         scoreValue.textContent = score;
                         messageBox.style.display = 'none';
                         setupLevel(); // Setup level 1
                         gameLoop(); // Ensure game loop is running
                     }

                     // Game loop
                     function update() {
                         if (gameOver) return;

                         // Control monster movement speed based on current level
                         monsterMoveCounter++;
                         const currentMonsterFreq = levels[currentLevel].monsterFreq;
                         if (monsterMoveCounter >= currentMonsterFreq) {
                             moveMonsters();
                             monsterMoveCounter = 0; // Reset counter
                         }

                          // Check if speed boost has expired
                         if (isSpeedBoostActive && Date.now() > speedBoostEndTime) {
                              isSpeedBoostActive = false;
                         }

                          // Check if invincibility has expired
                         if (isInvincible && Date.now() > invincibilityEndTime) {
                              isInvincible = false;
                              // Player color will revert in the draw function automatically
                         }

                     }

                     function draw() {
                         drawGrid();
                         drawGameObjects(); // Draw objects on top of the grid state
                     }

                     function gameLoop() {
                         update();
                         draw();
                         if (!gameOver) {
                              requestAnimationFrame(gameLoop); // Loop
                         }
                     }

                     // Event listener for keyboard input
                     window.addEventListener('keydown', (e) => {
                         if (gameOver) return;

                         switch (e.key) {
                             case 'ArrowUp':
                                 movePlayer(0, -1);
                                 break;
                             case 'ArrowDown':
                                 movePlayer(0, 1);
                                 break;
                             case 'ArrowLeft':
                                 movePlayer(-1, 0);
                                 break;
                             case 'ArrowRight':
                                 movePlayer(1, 0);
                                 break;
                         }
                          // movePlayer now calls draw() internally after processing steps
                     });

                      // Function to start continuous movement on button press
                      function startMove(dx, dy) {
                          if (gameOver || moveInterval !== null) return; // Don't start if game over or already moving

                          // Perform the first move immediately
                          movePlayer(dx, dy);

                          // Start the interval for continuous movement
                          moveInterval = setInterval(() => {
                              movePlayer(dx, dy);
                          }, moveRepeatFrequency); // Repeat movement based on frequency
                      }

                      // Function to stop continuous movement on button release
                      function stopMove() {
                          clearInterval(moveInterval);
                          moveInterval = null;
                      }


                      // Add event listeners for touch controls
                      upButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(0, -1); });
                      downButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(0, 1); });
                      leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(-1, 0); });
                      rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); startMove(1, 0); });

                      // Listen for touch end/cancel to stop movement
                      upButton.addEventListener('touchend', stopMove);
                      upButton.addEventListener('touchcancel', stopMove);
                      downButton.addEventListener('touchend', stopMove);
                      downButton.addEventListener('touchcancel', stopMove);
                      leftButton.addEventListener('touchend', stopMove);
                      leftButton.addEventListener('touchcancel', stopMove);
                      rightButton.addEventListener('touchend', stopMove);
                      rightButton.addEventListener('touchcancel', stopMove);


                      // Add event listeners for mouse clicks (for testing on desktop or devices with mouse)
                      upButton.addEventListener('mousedown', () => { startMove(0, -1); });
                      downButton.addEventListener('mousedown', () => { startMove(0, 1); });
                      leftButton.addEventListener('mousedown', () => { startMove(-1, 0); });
                      rightButton.addEventListener('mousedown', () => { startMove(1, 0); });

                      // Listen for mouse up to stop movement
                      upButton.addEventListener('mouseup', stopMove);
                      downButton.addEventListener('mouseup', stopMove);
                      leftButton.addEventListener('mouseup', stopMove);
                      rightButton.addEventListener('mouseup', stopMove);
                      // Also listen for mouseout in case the mouse leaves the button while held
                      upButton.addEventListener('mouseout', stopMove);
                      downButton.addEventListener('mouseout', stopMove);
                      leftButton.addEventListener('mouseout', stopMove);
                      rightButton.addEventListener('mouseout', stopMove);


                      // Event listener for restart button click
                     restartButton.addEventListener('click', restartLevel); // Default is to restart level


                     // Function to initialize and start the game
                     function initializeGame() {
                         // Set canvas size here to ensure it's done after the element is potentially visible
                         canvas.width = canvasSize;
                         canvas.height = canvasSize;
                         restartGame(); // Setup level 1 and start the loop
                     }

                     // Event listener for the start game button
                     startGameButton.addEventListener('click', () => {
                         startGameButton.style.display = 'none'; // Hide the button
                         gameWrapper.style.display = 'flex'; // Show the game container (using flex to center)
                         initializeGame(); // Initialize and start the game
                     });


                     // Handle window resize to keep canvas responsive (optional but good practice)
                     window.addEventListener('resize', () => {
                         // Recalculate canvas size based on container size on resize
                         // This is more robust for responsive design
                         if (!gameOver) { // Only redraw if game is active
                             canvas.width = canvas.offsetWidth;
                             canvas.height = canvas.offsetHeight; // Or maintain aspect ratio if needed
                             draw(); // Redraw content on resize
                         }
                     });


                  </script>
                 </section>
            </div>
    </main>

    <footer class="text-center py-8 mt-12 border-t border-gray-700">
        <p class="text-gray-400 text-sm">© 2025 MedFlow · Proyecto educativo de medicina interna y cardiología</p>
        <p class="text-gray-500 text-xs mt-1">Dr. Carlos Nader</p>
    </footer>

</body>
</html>
